#!/usr/bin/env python3
"""Manual BetMGM workflow.

Consumes predictions generated by `sports_analytics_agent.py`, computes stake
recommendations using a conservative Kelly-style sizing rule, stores pending
actions in `state/manual_bet_queue.json`, and pushes Telegram alerts so the
human operator can place wagers manually on BetMGM.
"""

from __future__ import annotations

import argparse
import json
import os
import time
import traceback
import uuid
from datetime import UTC, datetime, timedelta
from pathlib import Path
from typing import Any

# Detect Render environment - use Render paths if in cloud
RENDER_MODE = os.getenv("RENDER_MODE", "false").lower() == "true"

if RENDER_MODE:
    ROOT = Path("/opt/render/project/src")
else:
    ROOT = Path(os.path.expanduser("~/neolight"))

STATE = ROOT / "state"
LOGS = ROOT / "logs"

for directory in (STATE, LOGS):
    directory.mkdir(parents=True, exist_ok=True)

PREDICTIONS_FILE = STATE / "sports_predictions.json"
QUEUE_FILE = STATE / "manual_bet_queue.json"
BANKROLL_FILE = STATE / "sports_bankroll.json"

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

BANKROLL_INITIAL = float(os.getenv("SPORTS_BANKROLL_INITIAL", "1000"))
MAX_RISK_PER_BET = float(os.getenv("SPORTS_MAX_RISK_PER_BET", "0.02"))  # 2%
KELLY_SCALER = float(os.getenv("SPORTS_KELLY_SCALER", "0.5"))
EDGE_THRESHOLD = float(os.getenv("SPORTS_EDGE_THRESHOLD", "0.02"))
MIN_STAKE = float(os.getenv("SPORTS_MIN_STAKE", "5"))
POLL_INTERVAL = int(os.getenv("SPORTS_BETTING_INTERVAL", "1800"))  # 30 minutes

# Event recency thresholds
MAX_EVENT_LOOKAHEAD = timedelta(days=int(os.getenv("SPORTS_EVENT_LOOKAHEAD_DAYS", "10")))
MAX_EVENT_LAG = timedelta(days=int(os.getenv("SPORTS_EVENT_MAX_PAST_DAYS", "1")))

# Queue maintenance
MAX_QUEUE_LENGTH = int(os.getenv("SPORTS_MAX_QUEUE_ENTRIES", "250"))


def load_json(path: Path, default: Any) -> Any:
    if not path.exists():
        return default
    try:
        return json.loads(path.read_text())
    except json.JSONDecodeError:
        return default


def save_json(path: Path, payload: Any) -> None:
    path.write_text(json.dumps(payload, indent=2))


def load_bankroll() -> dict[str, Any]:
    data = load_json(BANKROLL_FILE, {})
    if not data:
        data = {
            "bankroll": BANKROLL_INITIAL,
            "initial_bankroll": BANKROLL_INITIAL,
            "updated_at": datetime.now(UTC).isoformat(),
        }
        save_json(BANKROLL_FILE, data)
    return data


def load_queue() -> list[dict[str, Any]]:
    queue = load_json(QUEUE_FILE, [])
    if not isinstance(queue, list):
        queue = []
    return queue


def prune_queue(queue: list[dict[str, Any]]) -> list[dict[str, Any]]:
    """Drop entries that are no longer pending or are out of recency bounds."""
    now = datetime.now(UTC)
    pruned: list[dict[str, Any]] = []
    for entry in queue:
        status = entry.get("status", "pending")
        scheduled = parse_event_datetime(entry.get("scheduled"))
        if status != "pending":
            continue
        if scheduled and (scheduled < now - MAX_EVENT_LAG or scheduled > now + MAX_EVENT_LOOKAHEAD):
            continue
        pruned.append(entry)
    if len(pruned) > MAX_QUEUE_LENGTH:
        pruned = pruned[-MAX_QUEUE_LENGTH:]
    return pruned


def send_telegram(message: str) -> None:
    if not (TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID):
        print("[sports_betting] Telegram credentials missing; skipping alert", flush=True)
        return
    try:
        import requests

        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": message, "parse_mode": "Markdown"}
        response = requests.post(url, json=payload, timeout=10)
        if response.status_code != 200:
            print(f"[sports_betting] Telegram send failed: {response.text}", flush=True)
    except Exception as exc:  # pragma: no cover - network failure path
        print(f"[sports_betting] Telegram error: {exc}", flush=True)


def compute_stake(bankroll: float, edge: float, confidence: float) -> float:
    edge = max(edge, 0.0)
    if edge <= EDGE_THRESHOLD:
        return 0.0
    kelly_fraction = edge / max(1.0 - confidence, 0.05)
    stake_fraction = min(MAX_RISK_PER_BET, kelly_fraction * KELLY_SCALER)
    stake = bankroll * stake_fraction
    return max(stake, 0.0)


def already_queued(queue: list[dict[str, Any]], game_id: str) -> bool:
    return any(
        entry.get("game_id") == game_id and entry.get("status") == "pending" for entry in queue
    )


def format_message(sport: str, prediction: dict[str, Any], stake: float) -> str:
    home = prediction["home_team"]
    away = prediction["away_team"]
    rec = prediction["recommended_side"]
    edge_pct = prediction.get("edge", 0.0) * 100
    conf_pct = prediction.get("confidence", 0.0) * 100
    scheduled = prediction.get("scheduled", "TBD")
    return (
        f"ðŸˆ *{sport.upper()} Edge Alert*\n"
        f"Game: {away} @ {home}\n"
        f"Recommended: *{rec}*\n"
        f"Stake: ${stake:,.2f}\n"
        f"Edge: {edge_pct:.2f}% | Confidence: {conf_pct:.2f}%\n"
        f"Kickoff: {scheduled}\n"
        f"Place manually on BetMGM and update the dashboard queue when finished."
    )


def parse_event_datetime(raw: str | None) -> datetime | None:
    """Parse various schedule formats into timezone-aware UTC datetime."""
    if not raw:
        return None
    raw = str(raw).strip()
    if not raw:
        return None

    # Common ISO/UTC formats (e.g. 2025-12-04T00:30:00+00:00)
    try:
        value = datetime.fromisoformat(raw.replace("Z", "+00:00"))
        if value.tzinfo is None:
            value = value.replace(tzinfo=UTC)
        return value.astimezone(UTC)
    except ValueError:
        pass

    # European style dates (31/10/2021)
    for fmt in ("%d/%m/%Y", "%d/%m/%y"):
        try:
            naive = datetime.strptime(raw, fmt)
            return naive.replace(tzinfo=UTC)
        except ValueError:
            continue

    return None


def within_recency_bounds(scheduled: datetime | None) -> bool:
    if scheduled is None:
        return False
    now = datetime.now(UTC)
    return now - MAX_EVENT_LAG <= scheduled <= now + MAX_EVENT_LOOKAHEAD


def process_predictions(predictions: dict[str, Any]) -> None:
    bankroll_state = load_bankroll()
    bankroll = float(bankroll_state.get("bankroll", BANKROLL_INITIAL))
    queue = prune_queue(load_queue())

    new_entries: list[dict[str, Any]] = []

    for sport, payload in predictions.items():
        if sport in {"last_update", "timestamp"}:
            continue
        for prediction in payload.get("predictions", []):
            game_id = prediction.get("game_id")
            edge = float(prediction.get("edge", 0.0))
            confidence = float(prediction.get("confidence", 0.0))
            scheduled_dt = parse_event_datetime(prediction.get("scheduled"))

            if already_queued(queue, game_id):
                continue

            stake = compute_stake(bankroll, edge, confidence)
            if stake < MIN_STAKE:
                continue

            if not within_recency_bounds(scheduled_dt):
                continue

            entry = {
                "id": str(uuid.uuid4()),
                "sport": sport,
                "game_id": game_id,
                "home_team": prediction.get("home_team"),
                "away_team": prediction.get("away_team"),
                "recommended_side": prediction.get("recommended_side"),
                "stake": round(stake, 2),
                "edge": round(edge, 4),
                "confidence": round(confidence, 4),
                "scheduled": prediction.get("scheduled"),
                "status": "pending",
                "created_at": datetime.now(UTC).isoformat(),
            }
            queue.append(entry)
            new_entries.append(entry)

            message = format_message(sport, prediction, stake)
            send_telegram(message)
            print(f"[sports_betting] queued manual bet {game_id} stake=${stake:,.2f}", flush=True)

    if new_entries:
        queue = prune_queue(queue)
        save_json(QUEUE_FILE, queue)
        log_path = LOGS / "sports_betting.log"
        with log_path.open("a", encoding="utf-8") as log_file:
            for entry in new_entries:
                log_file.write(json.dumps(entry) + "\n")


def notify_slate(predictions: dict[str, Any], sport_key: str, when: str) -> None:
    """
    Send a Telegram message listing matchups.
    - sport_key: e.g. 'nba' or 'soccer'
    - when: 'tonight' or 'tomorrow'
    """
    now = datetime.now(UTC)
    # Define day window
    if when == "tonight":
        start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        end = start + timedelta(days=1)
    elif when == "tomorrow":
        start = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
        end = start + timedelta(days=1)
    else:
        start = now - timedelta(hours=1)
        end = now + timedelta(days=1)

    payload = predictions.get(sport_key, {})
    games = []
    for p in payload.get("predictions", []):
        dt = parse_event_datetime(p.get("scheduled"))
        if not dt:
            continue
        if start <= dt < end:
            games.append((dt, p.get("away_team", "TBD"), p.get("home_team", "TBD")))
    games.sort(key=lambda x: x[0])
    if not games:
        send_telegram(f"ðŸ“£ No {sport_key.upper()} games in the requested window ({when}).")
        return
    lines = [f"ðŸ—“ {sport_key.upper()} slate ({when})"]
    for dt, away, home in games:
        lines.append(f"- {away} @ {home} â€¢ {dt.strftime('%Y-%m-%d %H:%M UTC')}")
    send_telegram("\n".join(lines))


def main() -> None:
    parser = argparse.ArgumentParser(description="Sports Betting Agent")
    parser.add_argument(
        "--notify-nba-tonight", action="store_true", help="Send NBA slate for tonight"
    )
    parser.add_argument(
        "--notify-soccer-tomorrow",
        action="store_true",
        default=False,
        help="Send Soccer slate for tomorrow",
    )
    args, unknown = parser.parse_known_args()

    if args.notify_nba_tonight or args.notify_soccer_tomorrow:
        preds = load_json(PREDICTIONS_FILE, {})
        if args.notify_nba_tonight:
            notify_slate(preds, "nba", "tonight")
        if args.notify_soccer_tomorrow:
            notify_slate(preds, "soccer", "tomorrow")
        return
    print(
        f"[sports_betting] Manual BetMGM agent running (bankroll=${BANKROLL_INITIAL:,.2f}, max risk={MAX_RISK_PER_BET * 100:.1f}%)",
        flush=True,
    )

    while True:
        try:
            predictions = load_json(PREDICTIONS_FILE, {})
            if predictions:
                process_predictions(predictions)
            else:
                print("[sports_betting] No predictions available yet", flush=True)
            time.sleep(POLL_INTERVAL)
        except KeyboardInterrupt:
            print("[sports_betting] Stopped by user", flush=True)
            break
        except Exception as exc:
            print(f"[sports_betting] Error: {exc}", flush=True)
            traceback.print_exc()
            time.sleep(300)


if __name__ == "__main__":
    main()
