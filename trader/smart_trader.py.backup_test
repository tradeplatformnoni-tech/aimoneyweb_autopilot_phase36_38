#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
NeoLight SmartTrader ‚Äî Paper Trading Implementation
---------------------------------------------------
Autonomous paper trading with signal generation, risk management,
and Telegram notifications.
"""
import os, sys, time, json, math, traceback, signal, datetime as dt
import logging
from pathlib import Path
from typing import Optional, Dict, List, Any
from collections import deque
from datetime import timezone

# Add backend to path for ledger integration
ROOT = Path(os.path.expanduser("~/neolight"))
sys.path.insert(0, str(ROOT))

# =============== LOGGING SETUP ==================
# Configure logging with file and console handlers
LOG_DIR = ROOT / "logs"
LOG_DIR.mkdir(parents=True, exist_ok=True)
LOG_FILE = LOG_DIR / "smart_trader.log"

# Create logger
logger = logging.getLogger("smart_trader")
logger.setLevel(logging.DEBUG)

# Prevent duplicate handlers
if not logger.handlers:
    # File handler
    file_handler = logging.FileHandler(LOG_FILE)
    file_handler.setLevel(logging.DEBUG)
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)

    # Console handler (INFO level for less noise)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter('%(levelname)s - %(message)s')
    console_handler.setFormatter(console_formatter)

# Try requests for Alpaca API (optional)
try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

# Import world-class QuoteService
try:
    # Try relative import first (same directory)
    from quote_service import get_quote_service, atomic_trade_context, ValidatedQuote
    HAS_QUOTE_SERVICE = True
except ImportError:
    try:
        # Try absolute import
        from trader.quote_service import get_quote_service, atomic_trade_context, ValidatedQuote
        HAS_QUOTE_SERVICE = True
    except ImportError:
        HAS_QUOTE_SERVICE = False
        logger.warning("‚ö†Ô∏è quote_service not available - using legacy quote fetching")

try:
    from backend.ledger_engine import record_fill, rebuild_equity_curve
except ImportError:
    print("‚ö†Ô∏è  ledger_engine not available - P&L tracking disabled")
    def record_fill(*args, **kwargs): pass
    def rebuild_equity_curve(): return 100000.0, 100000.0, 0.0, 0.0

# Try yfinance for market data
try:
    import yfinance as yf
    HAS_YFINANCE = True
except ImportError:
    print("‚ö†Ô∏è  Install yfinance: pip install yfinance")
    HAS_YFINANCE = False

# =============== SAFETY HANDLERS ==================
stop_flag = {"stop": False}
restart_count = 0
MAX_RESTARTS = 100  # Prevent infinite loops

def handle_stop(sig, frame):
    """Handle stop signals more gracefully - only stop on explicit user interrupt."""
    # Only stop if SIGINT (Ctrl+C) from user
    # Ignore SIGTERM (which Guardian might send during restart)
    if sig == signal.SIGINT:
        stop_flag["stop"] = True
        print("üõë Stop signal received ‚Äî preparing graceful shutdown...", flush=True)
    # For SIGTERM, log but don't stop (Guardian will restart if needed)
    elif sig == signal.SIGTERM:
        print("‚ö†Ô∏è  SIGTERM received (may be Guardian restart) - continuing...", flush=True)
        # Don't set stop_flag - let Guardian manage lifecycle

# Only catch SIGINT for user control
signal.signal(signal.SIGINT, handle_stop)
# Don't catch SIGTERM - let Guardian handle it

# =============== TELEGRAM ==================
def send_telegram(text: str, include_mode: bool = False, mode: Optional[str] = None, state: Optional[Dict] = None):
    """
    Send Telegram notification with optional mode display.

    Args:
        text: Message text
        include_mode: If True, prepend mode indicator
        mode: Trading mode (if None, extracted from state)
        state: State dictionary for mode extraction
    """
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    if not (token and chat_id):
        return

    # Format message with mode if requested
    if include_mode:
        if mode is None and state:
            mode = state.get("trading_mode", "TEST_MODE")

        if mode:
            # Mode emoji mapping
            mode_emoji = {
                "TEST_MODE": "üü£",
                "PAPER_TRADING_MODE": "üü¢",
                "LIVE_MODE": "üî¥"
            }
            emoji = mode_emoji.get(mode, "‚ö™")
            mode_display = f"{emoji} Mode: {mode}"
            text = f"{mode_display}\n{text}"

    try:
        import urllib.parse, urllib.request
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        data = urllib.parse.urlencode({"chat_id": chat_id, "text": text}).encode()
        urllib.request.urlopen(url, data=data, timeout=6)
    except Exception:
        pass  # Silent fail

# =============== UTILS ==================
def calculate_spread(bid: float, ask: float) -> float:
    """Compute bid-ask spread in basis points."""
    mid = (bid + ask) / 2.0
    return (ask - bid) / max(1e-9, mid) * 10000.0

def sma(series: List[float], n: int) -> Optional[float]:
    if len(series) < n:
        return None
    return sum(series[-n:]) / float(n)

def rsi(prices: List[float], n: int = 14) -> Optional[float]:
    if len(prices) < n + 1:
        return None
    gains = losses = 0.0
    for i in range(-n, 0):
        d = prices[i] - prices[i - 1]
        if d > 0:
            gains += d
        else:
            losses -= d
    if losses <= 0:
        return 100.0
    rs = gains / max(1e-9, losses)
    return 100.0 - (100.0 / (1.0 + rs))

def macd(prices: List[float], fast: int = 12, slow: int = 26, signal: int = 9) -> Optional[Dict[str, float]]:
    """Calculate MACD indicator."""
    if len(prices) < slow + signal:
        return None
    # Simplified: use SMA for EMA approximation
    fast_ema = sma(prices, fast)
    slow_ema = sma(prices, slow)
    if not (fast_ema and slow_ema):
        return None
    macd_line = fast_ema - slow_ema
    # Signal line approximation
    macd_hist = [macd_line]  # Simplified
    signal_line = macd_line * 0.9  # Approximation
    return {"macd": macd_line, "signal": signal_line, "histogram": macd_line - signal_line}

def bollinger_bands(prices: List[float], n: int = 20, std_dev: float = 2.0) -> Optional[Dict[str, float]]:
    """Calculate Bollinger Bands."""
    if len(prices) < n:
        return None
    sma_val = sma(prices, n)
    if not sma_val:
        return None
    # Calculate standard deviation
    variance = sum((p - sma_val) ** 2 for p in prices[-n:]) / n
    std = variance ** 0.5
    upper = sma_val + (std_dev * std)
    lower = sma_val - (std_dev * std)
    return {"upper": upper, "middle": sma_val, "lower": lower}

def atr(prices: List[float], n: int = 14) -> Optional[float]:
    """Average True Range for volatility."""
    if len(prices) < n + 1:
        return None
    true_ranges = []
    for i in range(-n, 0):
        high_low = abs(prices[i] - prices[i - 1])
        true_ranges.append(high_low)
    return sum(true_ranges) / len(true_ranges) if true_ranges else None

def calculate_momentum(prices: List[float], window: int = 5) -> Optional[float]:
    """Calculate momentum as % change over last N price points."""
    if len(prices) < window + 1:
        return None
    momentum = (prices[-1] - prices[-(window + 1)]) / prices[-(window + 1)]
    return round(momentum * 100, 3)  # return % change

def clamp(v: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, v))

# =============== WORLD-CLASS SAFE PRICE CONVERSION ==================
def safe_float_convert(value: Any, symbol: str = "UNKNOWN", context: str = "price", logger_instance: Optional[logging.Logger] = None, state: Optional[Dict] = None) -> Optional[float]:
    """
    World-class safe float conversion with comprehensive validation.
    Returns None if conversion fails, never raises ValueError.
    """
    log = logger_instance or logger

    # --- Step 1: Check for None, empty string, or invalid values ---
    if value is None:
        log.debug(f"‚ö†Ô∏è {symbol}: {context} is None")
        return None

    if value == '' or str(value).strip() == '':
        log.warning(f"‚ö†Ô∏è {symbol}: {context} is empty string")
        if state:
            send_telegram(
                f"üü£ Mode: {state.get('trading_mode', 'TEST_MODE')}\n"
                f"‚ö†Ô∏è Invalid {context} detected: {symbol}\n"
                f"Reason: Empty value received from data source.",
                include_mode=True,
                state=state
            )
        return None

    # --- Step 2: Check for string representations of NaN/None ---
    value_str = str(value).strip().lower()
    if value_str in ('nan', 'none', 'null', 'inf', '-inf', 'infinity', '-infinity'):
        log.warning(f"‚ö†Ô∏è {symbol}: {context} is invalid string: {value_str!r}")
        return None

    # --- Step 3: Attempt safe conversion ---
    try:
        converted = float(value)

        # --- Step 4: Validate reasonable range ---
        if converted <= 0:
            log.warning(f"‚ö†Ô∏è {symbol}: {context} is non-positive: {converted}")
            return None

        if converted > 1e10:  # Unrealistic price (e.g., > $10 billion)
            log.warning(f"‚ö†Ô∏è {symbol}: {context} is unrealistic: {converted}")
            return None

        return converted

    except (ValueError, TypeError, OverflowError) as e:
        log.error(f"‚ùå {symbol}: Failed to convert {context} to float: {value!r} ({type(value).__name__}) - {e}")
        if state:
            send_telegram(
                f"üü£ Mode: {state.get('trading_mode', 'TEST_MODE')}\n"
                f"‚ö†Ô∏è {context} conversion failed: {symbol}\n"
                f"Reason: {type(value).__name__} value '{value!r}' cannot be converted.",
                include_mode=True,
                state=state
            )
        return None

# =============== BROKER (PAPER TRADING) ==================
class PaperBroker:
    def __init__(self, starting_cash: float = 100000.0):
        self._cash = starting_cash
        self._positions: Dict[str, Dict[str, float]] = {}  # {symbol: {"qty": float, "avg_price": float}}
        self._equity = starting_cash
        self.fee_rate = 0.0002  # 2 bps per trade

    @property
    def cash(self) -> float:
        return self._cash

    @property
    def equity(self) -> float:
        return self._equity

    def fetch_quote(self, sym: str) -> Optional[Dict[str, float]]:
        """
        Fetch current quote with world-class multi-source fallback.
        Priority: Alpaca (if configured) -> Yahoo Finance -> Historical data.
        """
        # --- Method 1: Try Alpaca API (if configured) - Highest quality data ---
        alpaca_key = os.getenv("ALPACA_API_KEY")
        alpaca_secret = os.getenv("ALPACA_API_SECRET")
        use_alpaca = os.getenv("NEOLIGHT_USE_ALPACA_QUOTES", "false").lower() == "true"

        if use_alpaca and alpaca_key and alpaca_secret:
            if HAS_REQUESTS:
                try:
                    # Convert symbol format (BTC-USD -> BTCUSD for Alpaca)
                    alpaca_symbol = sym.replace("-", "") if "-" in sym else sym

                    # Try Alpaca quotes endpoint
                    headers = {
                        "APCA-API-KEY-ID": alpaca_key,
                        "APCA-API-SECRET-KEY": alpaca_secret
                    }

                    # Try crypto first (BTCUSD, ETHUSD)
                    if "USD" in alpaca_symbol and len(alpaca_symbol) <= 8:
                        url = f"https://data.alpaca.markets/v1beta3/crypto/latest/quotes"
                        params = {"symbols": alpaca_symbol}
                    else:
                        # Stocks
                        url = f"https://data.alpaca.markets/v2/stocks/{alpaca_symbol}/quotes/latest"
                        params = None

                    response = requests.get(url, headers=headers, params=params, timeout=5)
                    if response.status_code == 200:
                        data = response.json()

                        # Parse Alpaca response
                        if "quotes" in data:
                            # Crypto format
                            quotes = data.get("quotes", {})
                            if alpaca_symbol in quotes:
                                quote_data = quotes[alpaca_symbol]
                                price = quote_data.get("ap") or quote_data.get("bp") or quote_data.get("lp")
                            else:
                                price = None
                        elif "quote" in data:
                            # Stock format
                            quote_data = data["quote"]
                            price = quote_data.get("ap") or quote_data.get("bp") or quote_data.get("lp")
                        else:
                            price = None

                        if price is not None:
                            # --- World-Class Safe Conversion ---
                            safe_price = safe_float_convert(price, symbol=sym, context="Alpaca quote price")
                            if safe_price is not None and 1.0 <= safe_price <= 1e10:
                                logger.debug(f"üìä {sym} Quote (Alpaca): {safe_price:.2f}")
                                spread_pct = 0.0005
                                return {
                                    "bid": safe_price * (1 - spread_pct / 2),
                                    "ask": safe_price * (1 + spread_pct / 2),
                                    "mid": safe_price,
                                    "last": safe_price,
                                    "regularMarketPrice": safe_price,
                                    "currentPrice": safe_price,
                                    "source": "alpaca"
                                }
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è {sym}: Alpaca quote fetch failed: {e}")

        # --- Method 2: Yahoo Finance (fast_info) - Fast fallback ---
        if not HAS_YFINANCE:
            logger.warning(f"‚ö†Ô∏è yfinance not available, cannot fetch quote for {sym}")
            return None

        try:
            ticker = yf.Ticker(sym)

            # Method 1: Try fast_info first (faster, more reliable)
            try:
                fast_info = ticker.fast_info
                price = None

                # Try different fast_info attributes in order of preference
                for attr_name in ['lastPrice', 'regularMarketPrice', 'currentPrice']:
                    if hasattr(fast_info, attr_name):
                        attr_value = getattr(fast_info, attr_name)
                        if attr_value is not None:
                            # --- World-Class Safe Conversion ---
                            safe_price = safe_float_convert(attr_value, symbol=sym, context=f"fast_info.{attr_name}")
                            if safe_price is not None and 1.0 <= safe_price <= 1e10:
                                logger.debug(f"üìä {sym} Quote (fast_info.{attr_name}): {safe_price:.2f}")
                                spread_pct = 0.0005
                                return {
                                    "bid": safe_price * (1 - spread_pct / 2),
                                    "ask": safe_price * (1 + spread_pct / 2),
                                    "mid": safe_price,
                                    "last": safe_price,
                                    "regularMarketPrice": safe_price,
                                    "currentPrice": safe_price,
                                    "source": "yfinance_fast_info"
                                }
            except Exception as e:
                logger.debug(f"‚ö†Ô∏è {sym}: fast_info failed: {e}")

            # Method 2: Try historical data
            data = None
            periods_intervals = [
                ("1d", "1h"), ("2d", "1d"), ("5d", "1d"), ("1mo", "1d")
            ]

            for period, interval in periods_intervals:
                try:
                    data = ticker.history(period=period, interval=interval)
                    if data is not None and not data.empty and "Close" in data.columns:
                        break
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è {sym}: Failed to fetch {period}/{interval}: {e}")
                    continue

            if data is not None and not data.empty:
                try:
                    latest = data.iloc[-1]
                    # Try multiple price columns in order of preference
                    close_price = None
                    for price_col in ["Close", "Last", "regularMarketPrice", "currentPrice"]:
                        if price_col in data.columns:
                            close_price = latest.get(price_col)
                            if close_price is not None and str(close_price).strip() != '' and str(close_price).strip().lower() != 'nan':
                                break

                    # --- World-Class Safe Conversion ---
                    safe_price = safe_float_convert(close_price, symbol=sym, context="historical Close price")
                    if safe_price is not None and 1.0 <= safe_price <= 1e10:
                        logger.debug(f"üìä {sym} Quote (historical): {safe_price:.2f}")
                        spread_pct = 0.0005
                        bid = safe_price * (1 - spread_pct / 2)
                        ask = safe_price * (1 + spread_pct / 2)
                        return {
                            "bid": bid,
                            "ask": ask,
                            "mid": safe_price,
                            "last": safe_price,
                            "regularMarketPrice": safe_price,
                            "currentPrice": safe_price,
                            "source": "yfinance_historical"
                        }
                    else:
                        logger.debug(f"‚ö†Ô∏è {sym}: No valid price found in historical data")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {sym}: Failed to parse historical data: {e}")

            # All methods failed
            logger.warning(f"‚ö†Ô∏è Could not fetch quote for {sym}: all methods failed")
            return None

        except Exception as e:
            logger.error(f"‚ùå Quote fetch error for {sym}: {e}", exc_info=True)
            return None

    def get_position(self, sym: str) -> Dict[str, float]:
        return self._positions.get(sym, {"qty": 0.0, "avg_price": 0.0})

    def fetch_portfolio_value(self) -> float:
        """Calculate total portfolio value."""
        total = self._cash
        for sym, pos in self._positions.items():
            quote = self.fetch_quote(sym)
            if quote:
                price = quote.get("mid") or quote.get("last")
                safe_price = safe_float_convert(price, symbol=sym, context="portfolio valuation")
                if safe_price is not None:
                    total += pos["qty"] * safe_price
        self._equity = total
        return total

    def submit_order(self, sym: str, side: str, qty: float, price: float) -> Dict[str, Any]:
        """Submit paper trade order with world-class price validation."""
        # --- World-Class Safe Conversion (GUARANTEED to never raise ValueError for empty string) ---
        # Use safe_float_convert for ALL conversions - this is the critical fix
        safe_price = safe_float_convert(price, symbol=sym, context="submit_order price")
        if safe_price is None:
            error_msg = f"Invalid price parameter: {price} ({type(price).__name__})"
            logger.error(f"‚ùå {error_msg}")
            raise ValueError(error_msg)

        safe_qty = safe_float_convert(qty, symbol=sym, context="submit_order quantity")
        if safe_qty is None:
            error_msg = f"Invalid quantity parameter: {qty} ({type(qty).__name__})"
            logger.error(f"‚ùå {error_msg}")
            raise ValueError(error_msg)

        # Use safe converted values
        price = safe_price
        qty = safe_qty

        # Additional validation
        if qty <= 0:
            error_msg = f"Invalid quantity: {qty} (must be > 0)"
            logger.error(f"‚ùå {error_msg}")
            raise ValueError(error_msg)

        side = side.lower()

        # CRITICAL: Validate all internal state values before using them
        if not isinstance(self._cash, (int, float)):
            safe_cash = safe_float_convert(self._cash, symbol=sym, context="broker cash")
            if safe_cash is None:
                raise ValueError(f"Invalid broker cash: {self._cash!r}")
            self._cash = safe_cash

        fee = abs(qty * price * self.fee_rate)

        if side == "buy":
            cost = qty * price + fee
            if cost > self._cash:
                raise RuntimeError(f"Insufficient cash: need ${cost:.2f}, have ${self._cash:.2f}")
            self._cash -= cost
            pos = self.get_position(sym)

            # CRITICAL: Validate position values
            if not isinstance(pos.get("qty"), (int, float)):
                safe_qty_val = safe_float_convert(pos.get("qty"), symbol=sym, context="position qty")
                pos["qty"] = safe_qty_val if safe_qty_val is not None else 0.0
            if not isinstance(pos.get("avg_price"), (int, float)):
                safe_avg = safe_float_convert(pos.get("avg_price"), symbol=sym, context="position avg_price")
                pos["avg_price"] = safe_avg if safe_avg is not None else price

            if pos["qty"] > 0:
                # Average in
                total_cost = (pos["qty"] * pos["avg_price"]) + (qty * price)
                pos["qty"] += qty
                pos["avg_price"] = total_cost / pos["qty"]
            else:
                pos["qty"] = qty
                pos["avg_price"] = price
            self._positions[sym] = pos

        elif side == "sell":
            pos = self.get_position(sym)

            # CRITICAL: Validate position values
            if not isinstance(pos.get("qty"), (int, float)):
                safe_qty_val = safe_float_convert(pos.get("qty"), symbol=sym, context="position qty")
                pos["qty"] = safe_qty_val if safe_qty_val is not None else 0.0
            if not isinstance(pos.get("avg_price"), (int, float)):
                safe_avg = safe_float_convert(pos.get("avg_price"), symbol=sym, context="position avg_price")
                pos["avg_price"] = safe_avg if safe_avg is not None else price

            if qty > pos["qty"] + 1e-6:
                raise RuntimeError(f"Insufficient position: trying to sell {qty}, have {pos['qty']}")

            # CRITICAL: Ensure avg_price is valid before calculation
            avg_price = pos["avg_price"]
            if not isinstance(avg_price, (int, float)) or avg_price <= 0:
                logger.error(f"‚ùå Invalid avg_price for {sym}: {avg_price!r} ({type(avg_price)})")
                avg_price = price  # Fallback to current price

            pnl = (price - avg_price) * qty
            proceeds = qty * price - fee
            self._cash += proceeds
            pos["qty"] -= qty
            if pos["qty"] <= 1e-6:
                self._positions.pop(sym, None)
                # Realize P&L
                self._equity += pnl
            else:
                self._positions[sym] = pos
        else:
            raise RuntimeError(f"Invalid side: {side}")

        # Record trade (with safe conversion to prevent errors in record_fill)
        try:
            # CRITICAL: Ensure all values are valid floats before passing to record_fill
            # record_fill does float(qty), float(price), float(fee) which can fail on empty strings
            safe_fee = fee if isinstance(fee, (int, float)) else (safe_float_convert(fee, symbol=sym, context="fee") or 0.0)
            record_fill(sym, side, float(qty), float(price), float(safe_fee), note="paper_trade")
        except (ValueError, TypeError) as e:
            # Don't fail the trade if record_fill fails
            logger.warning(f"‚ö†Ô∏è Failed to record fill for {sym}: {e}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Unexpected error in record_fill for {sym}: {e}")

        return {
            "filled_qty": qty,
            "filled_price": price,
            "fee": fee,
            "pnl": pnl if side == "sell" else 0.0
        }

# =============== SIGNAL GENERATION ==================
def load_market_intelligence(sym: str) -> Optional[Dict[str, Any]]:
    """Load market intelligence for symbol."""
    intel_file = ROOT / "state" / "market_intelligence.json"
    if intel_file.exists():
        try:
            data = json.loads(intel_file.read_text())
            return data.get("signals", {}).get(sym)
        except:
            pass
    return None

def load_active_strategies() -> List[str]:
    """Load top-performing strategies from strategy_research agent."""
    strategies_file = ROOT / "state" / "strategy_performance.json"
    if strategies_file.exists():
        try:
            data = json.loads(strategies_file.read_text())
            active = data.get("active_strategies", [])
            # Extract strategy names, fallback to ranked if active empty
            strategies = [s.get("strategy") for s in active if s.get("strategy")]
            if strategies:
                return strategies
            # Fallback to ranked strategies (top 5)
            ranked = data.get("ranked_strategies", [])
            return [s.get("strategy") for s in ranked[:5] if s.get("strategy")]
        except Exception as e:
            print(f"‚ö†Ô∏è  Error loading strategies: {e}", flush=True)
    # Default fallback
    return ["turtle_trading", "mean_reversion_rsi", "momentum_sma_crossover", "pairs_trading", "vix_strategy"]

def generate_signal(broker: PaperBroker, sym: str, prices: deque, risk_scaler: float, confidence: float) -> Optional[str]:
    """Generate buy/sell signal using multi-source intelligence and proven strategies with adaptive weighting."""
    # Reduced minimum data requirement from 50 to 20 for faster signal generation
    if len(prices) < 20:
        return None

    price_list = list(prices)
    current_price = price_list[-1]

    # Calculate technical indicators
    sma_20 = sma(price_list, 20)
    sma_50 = sma(price_list, 50) if len(price_list) >= 50 else None
    rsi_val = rsi(price_list, 14)
    momentum = calculate_momentum(price_list, window=5)  # Calculate momentum

    if not all([sma_20, rsi_val]):
        return None

    # Get current position
    pos = broker.get_position(sym)
    has_position = pos["qty"] > 1e-6

    # Load market intelligence
    intel = load_market_intelligence(sym)
    market_sentiment = intel.get("composite_sentiment", 0.0) if intel else 0.0
    market_recommendation = intel.get("recommendation", "HOLD") if intel else "HOLD"

    # Load active strategies
    active_strategies = load_active_strategies()

    # Strategy signals (vote-based)
    strategy_votes = {"buy": 0, "sell": 0, "hold": 0}

    # Strategy 1: Turtle Trading (Trend Following)
    if "turtle_trading" in active_strategies:
        high_20 = max(price_list[-20:])
        low_10 = min(price_list[-10:]) if len(price_list) >= 10 else current_price
        if current_price > high_20 and not has_position:
            strategy_votes["buy"] += 1
        elif current_price < low_10 and has_position:
            strategy_votes["sell"] += 1

    # Strategy 2: Mean Reversion (RSI)
    # TEST MODE: Lowered thresholds for testing (was 30/70, now 45/55)
    if "mean_reversion_rsi" in active_strategies:
        if rsi_val < 45 and not has_position:  # TEST MODE: More aggressive (was 30)
            strategy_votes["buy"] += 1
        elif rsi_val > 55 and has_position:  # TEST MODE: More aggressive (was 70)
            strategy_votes["sell"] += 1

    # Strategy 3: Momentum SMA Crossover
    if "momentum_sma_crossover" in active_strategies and sma_50:
        if sma_20 > sma_50 and current_price > sma_20 and not has_position:
            strategy_votes["buy"] += 1
        elif sma_20 < sma_50 and has_position:
            strategy_votes["sell"] += 1

    # Strategy 4: Pairs Trading (Statistical Arbitrage) - TOP STRATEGY (1.8 Sharpe)
    if "pairs_trading" in active_strategies:
        # For pairs trading, need another correlated symbol
        # Simplified: use SPY/QQQ correlation
        if sym in ["SPY", "QQQ"]:
            # Would need price history of pair - placeholder for now
            # In full implementation, calculate spread Z-score
            pass

    # Strategy 5: VIX Fear Greed Strategy (1.6 Sharpe)
    if "vix_strategy" in active_strategies:
        # VIX strategy: buy when fear (VIX high), sell when greed (VIX low)
        # Simplified: check if we have VIX data or proxy
        # This would require separate VIX data feed
        pass

    # Strategy 6: Breakout Trading (Bollinger Bands)
    if "breakout_trading" in active_strategies:
        bb = bollinger_bands(price_list, 20, 2.0)
        if bb:
            if current_price > bb["upper"] and not has_position:
                strategy_votes["buy"] += 1  # Breakout above upper band
            elif current_price < bb["lower"] and has_position:
                strategy_votes["sell"] += 1  # Break below lower band

    # Strategy 7: MACD Momentum
    if "macd_momentum" in active_strategies:
        macd_data = macd(price_list, 12, 26, 9)
        if macd_data:
            if macd_data["macd"] > macd_data["signal"] and macd_data["histogram"] > 0 and not has_position:
                strategy_votes["buy"] += 1
            elif macd_data["macd"] < macd_data["signal"] and has_position:
                strategy_votes["sell"] += 1

    # Strategy 8: Bollinger Bands Mean Reversion
    if "bollinger_bands" in active_strategies:
        bb = bollinger_bands(price_list, 20, 2.0)
        if bb:
            if current_price < bb["lower"] and not has_position:
                strategy_votes["buy"] += 1  # Oversold - mean reversion buy
            elif current_price > bb["upper"] and has_position:
                strategy_votes["sell"] += 1  # Overbought - mean reversion sell

    # Combine signals with market intelligence
    final_signal = None

    # Technical signal (from strategies)
    tech_signal = None
    if strategy_votes["buy"] > strategy_votes["sell"] and strategy_votes["buy"] > 0:
        tech_signal = "buy"
    elif strategy_votes["sell"] > strategy_votes["buy"] and strategy_votes["sell"] > 0:
        tech_signal = "sell"

    # ADAPTIVE SIGNAL WEIGHTING: Momentum + Confidence fusion
    # If confidence > 0.7 and momentum < 0, bias toward SELL
    # If confidence > 0.7 and momentum > 0, bias toward BUY
    momentum_bias = None
    if confidence > 0.7 and momentum is not None:
        if momentum < 0:
            momentum_bias = "sell"
        elif momentum > 0:
            momentum_bias = "buy"

    # Market intelligence confirmation
    if tech_signal == "buy":
        # Buy if technical + positive sentiment OR high confidence OR positive momentum bias
        if market_sentiment > 0.2 or (market_recommendation == "BUY" and confidence > 0.5) or momentum_bias == "buy":
            final_signal = "buy"
        elif confidence < 0.3:  # Skip if low confidence
            final_signal = None
        else:
            final_signal = "buy"  # Technical signal strong enough

    elif tech_signal == "sell":
        # Sell if technical signal OR negative sentiment OR negative momentum bias
        if market_sentiment < -0.2 or market_recommendation == "SELL" or momentum_bias == "sell":
            final_signal = "sell"
        else:
            final_signal = "sell"  # Technical exit signal

    # ENHANCED SELL LOGIC: RSI > 80 and position > 0 triggers sell
    if rsi_val is not None and rsi_val > 80 and has_position and final_signal != "sell":
        final_signal = "sell"  # Overbought - force sell

    # Risk scaling: reduce position size if low confidence
    # TEST MODE: Lowered to 0.3 for easier testing (was 0.1)
    # Very low confidence (< 0.1) still blocks to prevent bad trades
    if final_signal == "buy" and confidence < 0.3:  # TEST MODE: More permissive (was 0.1)
        final_signal = None  # Skip trades only if confidence extremely low

    # ADDITIONAL FILTERING: Require stronger signal consensus
    # Reduced threshold to 1 for more trading activity (was 2)
    vote_threshold = 1  # Allow trades with single strong strategy
    if final_signal == "buy" and strategy_votes["buy"] < vote_threshold:
        final_signal = None  # Require at least 1 strategy confirmation

    if final_signal == "sell" and strategy_votes["sell"] < vote_threshold:
        # Allow sells with single strategy (exit protection)
        pass

    return final_signal

# =============== LOAD CONFIG ==================
def load_allocations() -> Dict[str, float]:
    """Load target allocations."""
    alloc_file = ROOT / "runtime" / "allocations_override.json"
    if alloc_file.exists():
        try:
            data = json.loads(alloc_file.read_text())
            return data.get("allocations", {})
        except:
            pass
    # Default allocations - Crypto 24/7 + Top Stocks/Commodities
    # World-class diversified portfolio for production trading
    # Crypto: Trade 24/7 for continuous market exposure
    # Stocks/Commodities: Trade during market hours only (9:30 AM - 4:00 PM ET)
    default_allocations = {
        # Crypto (24/7 trading) - 35% total
        "BTC-USD": 0.15,  # Bitcoin - Largest crypto by market cap
        "ETH-USD": 0.12,  # Ethereum - Smart contract platform
        "SOL-USD": 0.08,  # Solana - High-performance blockchain

        # Top Stocks (Market Hours: 9:30 AM - 4:00 PM ET) - 49% total
        "SPY": 0.10,   # S&P 500 ETF - Broad market exposure
        "QQQ": 0.10,   # Nasdaq 100 ETF - Tech sector
        "AAPL": 0.08,  # Apple - Tech giant
        "MSFT": 0.08,  # Microsoft - Cloud & enterprise
        "NVDA": 0.08,  # NVIDIA - AI/GPU leader
        "TSLA": 0.05,  # Tesla - EV/energy

        # Commodities (Market Hours) - 18% total
        "GLD": 0.08,   # Gold ETF - Safe haven asset
        "SLV": 0.05,   # Silver ETF - Precious metals
        "USO": 0.05,   # Oil ETF - Energy exposure
    }

    # Validate allocations sum to 1.0 (or close, with tolerance for rounding)
    total = sum(default_allocations.values())
    if abs(total - 1.0) > 0.01:  # Allow 1% tolerance
        logger.warning(f"‚ö†Ô∏è Default allocations sum to {total:.3f}, normalizing to 1.0")
        default_allocations = {k: v / total for k, v in default_allocations.items()}

    return default_allocations

def load_brain() -> Dict[str, float]:
    """Load orchestrator brain state."""
    brain_file = ROOT / "runtime" / "atlas_brain.json"
    if brain_file.exists():
        try:
            brain = json.loads(brain_file.read_text())
            # Ensure confidence is reasonable (not too low)
            if brain.get("confidence", 0.5) < 0.1:
                brain["confidence"] = 0.5  # Reset very low confidence to default
            return brain
        except:
            pass
    return {"risk_scaler": 1.0, "confidence": 0.5}

# =============== ATLAS BRIDGE INTEGRATION ==================
def send_to_atlas_bridge(data: Dict[str, Any]) -> bool:
    """Send telemetry data to Atlas Bridge for dashboard integration."""
    try:
        import requests
        dashboard_url = os.getenv("NEOLIGHT_DASHBOARD_URL", "http://localhost:8100")
        response = requests.post(
            f"{dashboard_url}/atlas/update",
            json=data,
            timeout=5
        )
        return response.status_code == 200
    except Exception:
        return False  # Silent fail if dashboard not available

# =============== PERFORMANCE ATTRIBUTION ==================
def track_trade_decision(symbol: str, side: str, reasoning: str, rsi: Optional[float], momentum: Optional[float], confidence: float) -> Optional[int]:
    """Track trade decision for performance attribution. Returns decision index."""
    try:
        sys.path.insert(0, str(ROOT))
        from agents.performance_attribution import track_decision

        agent_name = "SmartTrader"
        decision_str = f"{side.upper()} {symbol}"
        reasoning_full = f"RSI={rsi:.1f}, Momentum={momentum:.3f}%, Confidence={confidence:.2f} | {reasoning}" if rsi and momentum else f"Confidence={confidence:.2f} | {reasoning}"

        track_decision(agent_name, decision_str, reasoning_full)

        # Get decision index (latest decision)
        attribution_file = ROOT / "state" / "performance_attribution.json"
        if attribution_file.exists():
            data = json.loads(attribution_file.read_text())
            decisions = data.get("decisions", [])
            return len(decisions) - 1 if decisions else None
    except Exception:
        pass  # Silent fail if attribution not available
    return None

def update_trade_pnl(decision_idx: Optional[int], pnl: float) -> None:
    """Update P&L for tracked trade decision."""
    if decision_idx is None:
        return
    try:
        sys.path.insert(0, str(ROOT))
        from agents.performance_attribution import update_decision_pnl
        update_decision_pnl(decision_idx, pnl)
    except Exception:
        pass  # Silent fail

# =============== GUARDIAN AUTOPAUSE ==================
def check_guardian_pause(broker: PaperBroker, state: Dict[str, Any]) -> tuple[bool, float, str]:
    """
    Check if Guardian wants to pause trading (drawdown protection).
    Returns: (is_paused, current_drawdown_pct, reason)
    """
    try:
        # Check drawdown threshold (5-8% default)
        max_drawdown_pct = float(os.getenv("NEOLIGHT_MAX_DRAWDOWN_PCT", "8.0"))
        start_equity = state["daily"].get("start_equity", broker.equity)
        daily_pnl_pct = (broker.equity - start_equity) / max(1.0, start_equity) * 100
        current_drawdown = -daily_pnl_pct if daily_pnl_pct < 0 else 0.0

        if daily_pnl_pct <= -max_drawdown_pct:
            reason = f"Daily drawdown {current_drawdown:.2f}% exceeds threshold (-{max_drawdown_pct}%)"
            print(f"‚è∏Ô∏è GUARDIAN AUTOPAUSE: {reason}", flush=True)
            send_telegram(
                f"‚è∏Ô∏è Guardian AutoPause\n"
                f"üìâ Drawdown: {current_drawdown:.2f}%",
                include_mode=True,
                state=state
            )
            return (True, current_drawdown, reason)

        # Check for Guardian pause signal file
        pause_file = ROOT / "state" / "guardian_pause.json"
        if pause_file.exists():
            try:
                pause_data = json.loads(pause_file.read_text())
                if pause_data.get("paused", False):
                    reason = pause_data.get("reason", "Guardian intervention")
                    print(f"‚è∏Ô∏è GUARDIAN PAUSED: {reason}", flush=True)
                    return (True, current_drawdown, reason)
            except:
                pass

        return (False, current_drawdown, "Normal operation")

    except Exception:
        return (False, 0.0, "Error checking pause status")

# =============== CIRCUIT BREAKER ==================
class CircuitBreaker:
    """Circuit breaker pattern for error handling with state change tracking."""
    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 300, name: str = "CircuitBreaker"):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.name = name
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        self.previous_state = "CLOSED"  # Track state changes for alerts
        self.state_changed = False

    def record_success(self):
        """Record successful operation."""
        self.previous_state = self.state
        self.failure_count = 0
        if self.state != "CLOSED":
            self.state_changed = True
            self.state = "CLOSED"
        else:
            self.state_changed = False

    def record_failure(self):
        """Record failed operation."""
        self.previous_state = self.state
        self.failure_count += 1
        self.last_failure_time = time.time()
        if self.failure_count >= self.failure_threshold:
            if self.state != "OPEN":
                self.state_changed = True
                self.state = "OPEN"
                print(f"üî¥ {self.name} OPENED after {self.failure_count} failures", flush=True)
            else:
                self.state_changed = False
        else:
            self.state_changed = False

    def can_proceed(self) -> bool:
        """Check if operation can proceed."""
        self.state_changed = False
        if self.state == "CLOSED":
            return True
        elif self.state == "OPEN":
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.previous_state = self.state
                self.state = "HALF_OPEN"
                self.state_changed = True
                print(f"üü° {self.name} HALF_OPEN (recovery attempt)", flush=True)
                return True
            return False
        else:  # HALF_OPEN
            return True

    def get_state_info(self) -> Dict[str, Any]:
        """Get current state information for telemetry."""
        return {
            "state": self.state,
            "previous_state": self.previous_state,
            "state_changed": self.state_changed,
            "failure_count": self.failure_count,
            "failure_threshold": self.failure_threshold,
            "recovery_timeout": self.recovery_timeout,
            "time_until_recovery": max(0, self.recovery_timeout - (time.time() - self.last_failure_time)) if self.last_failure_time else 0
        }

# =============== MAIN LOOP ==================
def main():
    """
    SmartTrader Main Entrypoint
    Phase 5600+ Compliant | Supports Mode Persistence & Safe State
    World-class: Robust error handling, state persistence, graceful recovery
    """
    global state
    global logger

    # --- Step 1: Initialize state safely (load from file or create new) ---
    state = {}
    state_file = ROOT / "state" / "trader_state.json"

    try:
        if state_file.exists():
            with open(state_file, "r") as f:
                state = json.load(f)
                # Convert price_history lists back to deque if needed
                if "price_history" in state:
                    for sym, prices in state["price_history"].items():
                        if isinstance(prices, list):
                            state["price_history"][sym] = deque(prices, maxlen=200)
                        elif not isinstance(prices, deque):
                            state["price_history"][sym] = deque(maxlen=200)
                logger.info("üìÇ Loaded existing trader_state.json")
        else:
            state = {}
            logger.info("üÜï No existing state found ‚Äî starting fresh.")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Failed to load trader_state.json: {e}")
        state = {}

    # Ensure required state keys exist
    if "daily" not in state:
        state["daily"] = {}
    if "price_history" not in state:
        state["price_history"] = {}
    if "last_trade" not in state:
        state["last_trade"] = {}
    if "trade_count" not in state:
        state["trade_count"] = 0
    if "test_sells" not in state:
        state["test_sells"] = 0
    if "test_trade_executed" not in state:
        state["test_trade_executed"] = False

    # --- Step 2: Load trading mode from persistence ---
    trading_mode = "TEST_MODE"  # Default
    mode_file = ROOT / "state" / "trading_mode.json"

    try:
        if mode_file.exists():
            with open(mode_file, "r") as f:
                mode_data = json.load(f)
                persisted_mode = mode_data.get("mode", "TEST_MODE")
                if persisted_mode in ["TEST_MODE", "PAPER_TRADING_MODE", "LIVE_MODE"]:
                    trading_mode = persisted_mode
                    logger.info(f"üîÅ Loaded trading mode: {trading_mode}")
                else:
                    logger.warning(f"‚ö†Ô∏è Invalid mode in file: {persisted_mode}, defaulting to TEST_MODE")
        else:
            trading_mode = "TEST_MODE"
            logger.info("‚öôÔ∏è No mode file found ‚Äî defaulting to TEST_MODE")
    except Exception as e:
        logger.error(f"‚ùå Error loading trading_mode.json: {e}")
        trading_mode = "TEST_MODE"

    # --- Step 3: Bind mode to state & persist immediately ---
    state["trading_mode"] = trading_mode

    try:
        # Ensure state directory exists
        (ROOT / "state").mkdir(parents=True, exist_ok=True)

        # Save state
        state_to_save = state.copy()
        # Convert deque to list for JSON serialization
        if "price_history" in state_to_save:
            state_to_save["price_history"] = {
                sym: list(prices) if isinstance(prices, deque) else prices
                for sym, prices in state_to_save["price_history"].items()
            }

        with open(state_file, "w") as f:
            json.dump(state_to_save, f, indent=4)
        logger.info(f"üíæ State initialized with mode={trading_mode}")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Could not save trader_state.json: {e}")

    # --- Step 4: Initialize QuoteService (if available) ---
    quote_service = None
    if HAS_QUOTE_SERVICE:
        try:
            quote_service = get_quote_service()
            logger.info("‚úÖ QuoteService initialized (world-class immutable quotes)")
            logger.info(f"üìä Quote sources: Alpaca={'‚úÖ' if os.getenv('NEOLIGHT_USE_ALPACA_QUOTES', 'false').lower() == 'true' else '‚ùå'} | "
                       f"Finnhub={'‚úÖ' if os.getenv('FINNHUB_API_KEY') else '‚ùå'} | "
                       f"TwelveData={'‚úÖ' if os.getenv('TWELVEDATA_API_KEY') else '‚ùå'} | "
                       f"Yahoo={'‚úÖ' if HAS_YFINANCE else '‚ùå'}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è QuoteService initialization failed: {e}")
            quote_service = None

    # --- Step 5: Core startup banner ---
    print(f"üü£ SmartTrader starting ({trading_mode})", flush=True)
    logger.info(f"üü£ SmartTrader starting ({trading_mode})")
    logger.info("üìä System check: Guardian + CircuitBreaker active.")
    logger.info("üîÅ Pre-loading market data...")

    # Enhanced startup message with symbol count
    allocations = load_allocations()
    symbol_count = len(allocations)
    send_telegram(
        f"SmartTrader active with {symbol_count} symbols.\n"
        f"üìä Guardian + CircuitBreaker: Active\n"
        f"üîÅ Pre-loading market data...",
        include_mode=True,
        mode=trading_mode,
        state=state
    )

    # --- Step 5: Initialize broker and complete state setup ---
    broker = PaperBroker(starting_cash=100000.0)

    # Initialize price history
    allocations = load_allocations()
    SYMBOLS = list(allocations.keys())

    for sym in SYMBOLS:
        state["price_history"][sym] = deque(maxlen=200)
        state["last_trade"][sym] = 0

    # PRE-LOAD price history to speed up trading start
    print("üìä Pre-loading price history for faster trading start...", flush=True)
    if HAS_YFINANCE:
        for sym in SYMBOLS:
            try:
                ticker = yf.Ticker(sym)
                # Try to get historical data with more granular intervals
                # Try 1h, 5m, 1d intervals to get 20+ points
                prices_to_add = []
                for period, interval in [("5d", "1h"), ("1d", "5m"), ("1mo", "1d"), ("3mo", "1d")]:
                    try:
                        hist_data = ticker.history(period=period, interval=interval)
                        if not hist_data.empty:
                            # Get last 25 prices (we need 20, get extra for buffer)
                            prices_to_add = hist_data["Close"].tail(25).tolist()
                            if len(prices_to_add) >= 15:  # Have enough data
                                break
                    except:
                        continue

                if prices_to_add:
                    # Add prices to history
                    for price in prices_to_add:
                        state["price_history"][sym].append(float(price))
                    print(f"  ‚úÖ {sym}: Pre-loaded {len(prices_to_add)} price points", flush=True)
                else:
                    print(f"  ‚ö†Ô∏è {sym}: Could not pre-load history (will collect gradually)", flush=True)
            except Exception as e:
                print(f"  ‚ö†Ô∏è {sym}: Could not pre-load history: {e}", flush=True)

    print(f"üìä Trading symbols: {SYMBOLS}", flush=True)
    print(f"üí∞ Starting capital: ${broker.equity:,.2f}", flush=True)

    loop_count = 0
    consecutive_errors = 0
    MAX_CONSECUTIVE_ERRORS = 10

    # Initialize circuit breakers for critical operations
    quote_breaker = CircuitBreaker(failure_threshold=10, recovery_timeout=300, name="QuoteFetcher")
    trade_breaker = CircuitBreaker(failure_threshold=5, recovery_timeout=600, name="TradeExecution")

    # Track decision indices for P&L attribution
    pending_decisions: Dict[str, int] = {}  # {symbol: decision_idx}

    # Track circuit breaker state changes for Telegram alerts
    last_circuit_states = {
        "quote": "CLOSED",
        "trade": "CLOSED"
    }

    # --- Main trading loop with state persistence ---
    try:
        while not stop_flag["stop"]:
            try:
                now = dt.datetime.now()
                loop_count += 1
                consecutive_errors = 0  # Reset on successful iteration

                # Daily reset
                if "date" not in state.get("daily", {}) or "start_equity" not in state.get("daily", {}):
                    state["daily"] = {
                        "date": now.date().isoformat(),
                        "pnl_pct": 0.0,
                        "start_equity": broker.equity
                    }
                    print(f"üîÅ New trading day: {state['daily']['date']}", flush=True)
                    send_telegram(
                        f"üîÅ New Trading Day: {state['daily']['date']}\n"
                        f"üí∞ Starting Equity: ${broker.equity:,.2f}",
                        include_mode=True,
                        state=state
                    )

                if state["daily"]["date"] != now.date().isoformat():
                    # Calculate daily P&L (ensure start_equity exists)
                    start_equity = state["daily"].get("start_equity", broker.equity)
                    daily_pnl = (broker.equity - start_equity) / max(1.0, start_equity) * 100
                    print(f"üìä Daily P&L: {daily_pnl:.2f}% | Equity: ${broker.equity:,.2f}", flush=True)
                    send_telegram(
                        f"üìä Daily P&L: {daily_pnl:.2f}% | Equity: ${broker.equity:,.2f}",
                        include_mode=True,
                        state=state
                    )

                    # Reset for new day
                    state["daily"] = {
                        "date": now.date().isoformat(),
                        "pnl_pct": 0.0,
                        "start_equity": broker.equity
                    }

                # Load brain state
                brain = load_brain()
                risk_scaler = brain.get("risk_scaler", 1.0)
                confidence = brain.get("confidence", 0.5)

                # Update portfolio value
                broker.fetch_portfolio_value()

                # GUARDIAN AUTOPAUSE: Check if Guardian wants to pause trading
                is_paused, guardian_drawdown, pause_reason = check_guardian_pause(broker, state)
                if is_paused:
                    print(f"‚è∏Ô∏è Trading paused by Guardian - {pause_reason} | Waiting 60s before retry...", flush=True)
                    # Send pause telemetry
                    send_to_atlas_bridge({
                        "type": "guardian_pause",
                        "is_paused": True,
                        "current_drawdown": guardian_drawdown,
                        "reason": pause_reason,
                        "mode": trading_mode,
                        "timestamp": dt.datetime.now(timezone.utc).isoformat()
                    })
                    time.sleep(60)
                    continue

                # Market hours check (9:30 AM - 4:00 PM ET, Mon-Fri)
                # Crypto trades 24/7, stocks/commodities only during market hours
                is_market_hours = False
                now_et = dt.datetime.now(dt.timezone(dt.timedelta(hours=-5)))  # EST (adjust for DST if needed)
                if now_et.weekday() < 5:  # Monday = 0, Friday = 4
                    market_open = dt.time(9, 30)  # 9:30 AM
                    market_close = dt.time(16, 0)   # 4:00 PM
                    current_time = now_et.time()
                    is_market_hours = market_open <= current_time <= market_close

                # Separate crypto (24/7) from stocks/commodities (market hours only)
                crypto_symbols = [s for s in SYMBOLS if "-USD" in s or s in ["BTC-USD", "ETH-USD", "SOL-USD"]]
                stock_commodity_symbols = [s for s in SYMBOLS if s not in crypto_symbols]

                # Trade crypto 24/7
                symbols_to_trade = crypto_symbols.copy()

                # Trade stocks/commodities only during market hours
                if is_market_hours:
                    symbols_to_trade.extend(stock_commodity_symbols)
                    if loop_count % 100 == 0:  # Log every ~8 minutes
                        print(f"üìà Market OPEN - Trading stocks/commodities", flush=True)
                else:
                    if loop_count % 100 == 0:  # Log every ~8 minutes
                        print(f"üåô Market CLOSED - Trading crypto only", flush=True)

                # Log loop activity every 20 iterations (~100 seconds) for visibility
                if loop_count % 20 == 0:
                    crypto_count = len([s for s in symbols_to_trade if "-USD" in s])
                    print(f"üîÑ Loop {loop_count} | Trading {len(symbols_to_trade)} symbols ({crypto_count} crypto)", flush=True)

                # Prioritize: Top stocks first, then commodities, then crypto
                symbol_priority = sorted(symbols_to_trade, key=lambda x: (
                    x not in ["SPY", "QQQ", "AAPL", "MSFT", "NVDA"],  # Top stocks first
                    x not in ["GLD", "SLV", "USO"],  # Commodities second
                    x  # Then crypto
                ))

                for sym in symbol_priority:
                    # Circuit breaker check for quote fetching
                    if not quote_breaker.can_proceed():
                        continue

                    quote = broker.fetch_quote(sym)
                    if not quote:
                        quote_breaker.record_failure()
                        # Log failures for debugging
                        if sym not in ["BTC-USD", "ETH-USD", "USDT/USD"]:
                            print(f"‚ö†Ô∏è  Failed to fetch quote for {sym} - may need different data source", flush=True)
                        continue

                    quote_breaker.record_success()  # Successful quote fetch

                    # --- World-Class Safe Price Validation & Conversion ---
                    price_raw = quote.get("mid") or quote.get("last") or quote.get("regularMarketPrice") or quote.get("currentPrice")

                    # Use safe conversion function
                    safe_price = safe_float_convert(price_raw, symbol=sym, context="main loop quote price", state=state)
                    if safe_price is None:
                        logger.warning(f"‚ö†Ô∏è Quote for {sym} missing or invalid price: {quote}")
                        continue

                    # CRITICAL: Use safe_price everywhere, never the raw price
                    price = safe_price

                    state["price_history"][sym].append(price)

                    # Log progress collecting data
                    data_count = len(state["price_history"][sym])
                    # Log data collection progress more frequently
                    if loop_count % 20 == 0:  # Log every ~100 seconds
                        print(f"üìä {sym}: {data_count} price points | Current: ${price:.2f}", flush=True)

                    # Check if enough data (reduced from 50 to 20 for faster start)
                    if data_count < 20:
                        if loop_count % 20 == 0:
                            print(f"‚è≥ {sym}: Waiting for more data ({data_count}/20 points)", flush=True)
                        continue

                    # Cooldown: don't trade too frequently (increased to 15 min to reduce overtrading)
                    if time.time() - state["last_trade"].get(sym, 0) < 900:  # 15 min cooldown
                        continue

                    # Calculate indicators for detailed logging (always calculate momentum)
                    price_list = list(state["price_history"][sym])
                    rsi_val = rsi(price_list, min(14, len(price_list) - 1)) if len(price_list) >= 15 else None
                    sma_20 = sma(price_list, min(20, len(price_list))) if len(price_list) >= 10 else None
                    momentum = calculate_momentum(price_list, window=5)  # Use proper momentum function

                    # ENHANCED SELL LOGIC: RSI > 80 and position > 0 triggers sell (even without strategy vote)
                    pos = broker.get_position(sym)
                    has_position = pos["qty"] > 1e-6

                    # Generate signal (now uses market intelligence + strategy research + momentum)
                    signal = generate_signal(broker, sym, state["price_history"][sym], risk_scaler, confidence)

                    # Override signal if RSI > 80 and we have a position (overbought sell)
                    if rsi_val is not None and rsi_val > 80 and has_position and signal != "sell":
                        signal = "sell"

                    # DEBUG: Log detailed signal info with RSI, SMA, momentum (always log momentum)
                    if loop_count % 20 == 0:  # Every ~100 seconds
                        data_count = len(state["price_history"][sym])
                        rsi_str = f"{rsi_val:.1f}" if rsi_val else "N/A"
                        sma_str = f"${sma_20:.2f}" if sma_20 else "N/A"
                        momentum_str = f"{momentum:.3f}%" if momentum is not None else "N/A"
                        mode_str = f"[{trading_mode}]" if trading_mode == "TEST_MODE" else ""
                        print(f"üîç {sym}: RSI={rsi_str} SMA={sma_str} Momentum={momentum_str} ‚Üí signal={signal if signal else 'None'}, position={pos['qty']:.4f}, confidence={confidence:.2f} {mode_str}", flush=True)

                    if not signal:
                        continue

                    # Circuit breaker check for trading
                    if not trade_breaker.can_proceed():
                        print(f"‚è∏Ô∏è Circuit breaker OPEN - skipping trade for {sym}", flush=True)
                        continue

                    # Track decision for performance attribution
                    reasoning = f"Signal generated: {signal} (RSI={rsi_val:.1f}, Momentum={momentum:.3f}%, Confidence={confidence:.2f})"
                    decision_idx = track_trade_decision(sym, signal, reasoning, rsi_val, momentum, confidence)
                    if decision_idx is not None:
                        pending_decisions[sym] = decision_idx

                    # Calculate position size based on allocation
                    target_allocation = allocations.get(sym, 0.0) * risk_scaler
                    portfolio_value = broker.fetch_portfolio_value()
                    target_value = portfolio_value * target_allocation
                    current_value = broker.get_position(sym)["qty"] * price

                    if signal == "buy":
                        # Check if we need to buy more
                        # INCREASED threshold from 5% to 10% to reduce overtrading
                        if current_value < target_value * 0.90:  # 10% threshold
                            buy_value = min(target_value - current_value, broker.cash * 0.95)
                            # ADD MAX POSITION SIZE: Don't allocate more than 30% per trade
                            max_trade_size = portfolio_value * 0.30
                            buy_value = min(buy_value, max_trade_size)
                            qty = buy_value / price
                            if qty > 0.001:  # Minimum trade size
                                try:
                                    # Add to approval queue for large trades (>$1000)
                                    if buy_value > 1000.0:
                                        approval_data = {
                                            "type": "BUY",
                                            "symbol": sym,
                                            "qty": qty,
                                            "price": price,
                                            "amount": buy_value,
                                            "details": f"BUY {qty:.4f} {sym} @ ${price:.2f}"
                                        }
                                        try:
                                            approval_file = ROOT / "state" / "approval_queue.json"
                                            if approval_file.exists():
                                                queue = json.loads(approval_file.read_text())
                                            else:
                                                queue = []
                                            approval_data["id"] = len(queue) + 1
                                            approval_data["timestamp"] = dt.datetime.now(timezone.utc).isoformat()
                                            queue.append(approval_data)
                                            approval_file.write_text(json.dumps(queue, indent=2))
                                            send_telegram(
                                                f"‚è∏Ô∏è Pending Approval: BUY {sym}\n"
                                                f"üí∞ Amount: ${buy_value:,.2f}\n"
                                                f"üìä Check dashboard for approval",
                                                include_mode=True,
                                                state=state
                                            )
                                            print(f"‚è∏Ô∏è Trade queued for approval (amount: ${buy_value:,.2f})", flush=True)
                                            continue
                                        except:
                                            pass  # If approval system not available, proceed

                                    try:
                                        result = broker.submit_order(sym, "buy", qty, price)
                                        trade_breaker.record_success()  # Successful trade
                                        state["last_trade"][sym] = time.time()
                                        state["trade_count"] += 1
                                    except Exception as trade_error:
                                        trade_breaker.record_failure()
                                        raise trade_error

                                    # Log based on mode
                                    if trading_mode == "TEST_MODE":
                                        print(f"üß™ TEST BUY: {sym}: {qty:.4f} @ ${price:.2f} | RSI={rsi_val:.1f} | Momentum={momentum:.3f}% | Confidence={confidence:.2f} | Fee: ${result['fee']:.2f}", flush=True)
                                        send_telegram(
                                            f"üß™ TEST BUY: {sym}\n"
                                            f"üìä Size: {qty:.4f} @ ${price:.2f}\n"
                                            f"üìà RSI: {rsi_val:.1f} | Momentum: {momentum:.3f}% | Confidence: {confidence:.2f}",
                                            include_mode=True,
                                            state=state
                                        )
                                    else:
                                        print(f"‚úÖ PAPER BUY: {sym}: {qty:.4f} @ ${price:.2f} | RSI={rsi_val:.1f} | Momentum={momentum:.3f}% | Confidence={confidence:.2f} | Fee: ${result['fee']:.2f}", flush=True)
                                        send_telegram(
                                            f"‚úÖ PAPER BUY: {sym}\n"
                                            f"üìä Size: {qty:.4f} @ ${price:.2f}\n"
                                            f"üìà RSI: {rsi_val:.1f} | Momentum: {momentum:.3f}% | Confidence: {confidence:.2f}",
                                            include_mode=True,
                                            state=state
                                        )

                                    # Update performance attribution (buy has no P&L yet)
                                    # P&L will be updated on sell

                                    # Enhanced trade telemetry with circuit breaker states
                                    start_equity = state["daily"].get("start_equity", broker.equity)
                                    daily_pnl_pct = (broker.fetch_portfolio_value() - start_equity) / max(1.0, start_equity) * 100
                                    current_drawdown = -daily_pnl_pct if daily_pnl_pct < 0 else 0.0

                                    send_to_atlas_bridge({
                                        "type": "trade",
                                        "symbol": sym,
                                        "side": "buy",
                                        "qty": qty,
                                        "price": price,
                                        "rsi": rsi_val,
                                        "momentum": momentum,
                                        "confidence": confidence,
                                        "mode": trading_mode,
                                        "current_drawdown": current_drawdown,
                                        "circuit_breaker_state": {
                                            "quote": quote_breaker.get_state_info()["state"],
                                            "trade": trade_breaker.get_state_info()["state"]
                                        },
                                        "timestamp": dt.datetime.now(timezone.utc).isoformat()
                                    })
                                except Exception as e:
                                    print(f"‚ùå Buy error: {e}", flush=True)

                    elif signal == "sell":
                        pos = broker.get_position(sym)
                        if pos["qty"] > 1e-6:
                            # Sell entire position or trim
                            sell_qty = pos["qty"]
                            # INCREASED threshold from 5% to 10% to reduce overtrading
                            if current_value > target_value * 1.10:  # 10% threshold
                                sell_qty = min(sell_qty, (current_value - target_value) / price)

                            if sell_qty > 1e-6:
                                try:
                                    result = broker.submit_order(sym, "sell", sell_qty, price)
                                    trade_breaker.record_success()  # Successful trade
                                    state["last_trade"][sym] = time.time()
                                    state["trade_count"] += 1
                                    pnl = result.get("pnl", 0)
                                    pnl_pct = (pnl / (sell_qty * pos["avg_price"])) * 100 if sell_qty > 0 else 0

                                    # Update performance attribution with P&L
                                    decision_idx = pending_decisions.pop(sym, None)
                                    if decision_idx is not None:
                                        update_trade_pnl(decision_idx, pnl)

                                    # Track test sells for mode transition
                                    if trading_mode == "TEST_MODE":
                                        # CRITICAL: Ensure test_sells counter exists and increment
                                        if "test_sells" not in state:
                                            state["test_sells"] = 0
                                        state["test_sells"] += 1
                                        test_sell_count = state["test_sells"]

                                        # CRITICAL: Save state immediately after increment
                                        try:
                                            state_to_save = state.copy()
                                            if "price_history" in state_to_save:
                                                state_to_save["price_history"] = {
                                                    sym: list(prices) if isinstance(prices, deque) else prices
                                                    for sym, prices in state_to_save["price_history"].items()
                                                }
                                            state_file = ROOT / "state" / "trader_state.json"
                                            with open(state_file, "w") as f:
                                                json.dump(state_to_save, f, indent=4)
                                            logger.info(f"üíæ Saved state: test_sells={test_sell_count}")
                                        except Exception as e:
                                            logger.warning(f"‚ö†Ô∏è Could not save state after test sell: {e}")

                                        print(f"üß™ TEST SELL: {sym}: {sell_qty:.4f} @ ${price:.2f} | RSI={rsi_val:.1f} | Momentum={momentum:.3f}% | Confidence={confidence:.2f} | P&L: ${result.get('pnl', 0):.2f} ({pnl_pct:.2f}%) | Test sells: {test_sell_count}/2", flush=True)
                                        logger.info(f"üìä Test sell #{test_sell_count} completed for {sym}")

                                        send_telegram(
                                            f"üß™ TEST SELL #{test_sell_count}: {sym}\n"
                                            f"üìä Size: {sell_qty:.4f} @ ${price:.2f}\n"
                                            f"üí∞ P&L: ${result.get('pnl', 0):.2f}\n"
                                            f"üìà Progress: {test_sell_count}/2 test sells",
                                            include_mode=True,
                                            state=state
                                        )

                                        # Auto-switch to PAPER_TRADING_MODE after 2 test sells
                                        logger.info(f"üîç Checking transition: test_sell_count={test_sell_count}, trading_mode={trading_mode}")
                                        if test_sell_count >= 2:
                                            trading_mode = "PAPER_TRADING_MODE"
                                            state["trading_mode"] = trading_mode  # Persist mode in state

                                            # Persist mode to file for recovery
                                            try:
                                                (ROOT / "state").mkdir(parents=True, exist_ok=True)
                                                mode_file = ROOT / "state" / "trading_mode.json"
                                                mode_file.write_text(json.dumps({
                                                    "mode": trading_mode,
                                                    "timestamp": dt.datetime.now(timezone.utc).isoformat(),
                                                    "reason": "2 test sells completed"
                                                }, indent=2))
                                                logger.info(f"üíæ Saved trading mode: {trading_mode}")

                                                # Also save state immediately
                                                state_to_save = state.copy()
                                                if "price_history" in state_to_save:
                                                    state_to_save["price_history"] = {
                                                        sym: list(prices) if isinstance(prices, deque) else prices
                                                        for sym, prices in state_to_save["price_history"].items()
                                                    }
                                                state_file = ROOT / "state" / "trader_state.json"
                                                with open(state_file, "w") as f:
                                                    json.dump(state_to_save, f, indent=4)
                                            except Exception as e:
                                                logger.warning(f"‚ö†Ô∏è Could not persist mode: {e}")

                                            print(f"üöÄ Switching SmartTrader from TEST MODE ‚Üí PAPER_TRADING_MODE", flush=True)
                                            print(f"‚úÖ Mode transition complete: {trading_mode}", flush=True)
                                            logger.info(f"‚úÖ Transition trigger: 2 test sells completed")
                                            logger.info(f"üîÅ Switching from TEST_MODE ‚Üí PAPER_TRADING_MODE")
                                            send_telegram(
                                                "üöÄ Mode Transition: TEST_MODE ‚Üí PAPER_TRADING_MODE\n"
                                                "‚úÖ 2 test sells completed successfully\n"
                                                "üü¢ Paper trading now active",
                                                include_mode=True,
                                                mode="PAPER_TRADING_MODE",
                                                state=state
                                            )

                                            # Send mode transition telemetry
                                            send_to_atlas_bridge({
                                                "type": "mode_transition",
                                                "from": "TEST_MODE",
                                                "to": "PAPER_TRADING_MODE",
                                                "reason": "2 test sells completed",
                                                "timestamp": dt.datetime.now(timezone.utc).isoformat()
                                            })
                                    else:
                                        print(f"‚úÖ PAPER SELL: {sym}: {sell_qty:.4f} @ ${price:.2f} | RSI={rsi_val:.1f} | Momentum={momentum:.3f}% | Confidence={confidence:.2f} | P&L: ${result.get('pnl', 0):.2f} ({pnl_pct:.2f}%)", flush=True)
                                        send_telegram(
                                            f"‚úÖ PAPER SELL: {sym}\n"
                                            f"üìä Size: {sell_qty:.4f} @ ${price:.2f}\n"
                                            f"üí∞ P&L: ${result.get('pnl', 0):.2f}",
                                            include_mode=True,
                                            state=state
                                        )

                                    # Enhanced trade telemetry with circuit breaker states
                                    start_equity = state["daily"].get("start_equity", broker.equity)
                                    daily_pnl_pct = (broker.fetch_portfolio_value() - start_equity) / max(1.0, start_equity) * 100
                                    current_drawdown = -daily_pnl_pct if daily_pnl_pct < 0 else 0.0

                                    send_to_atlas_bridge({
                                        "type": "trade",
                                        "symbol": sym,
                                        "side": "sell",
                                        "qty": sell_qty,
                                        "price": price,
                                        "rsi": rsi_val,
                                        "momentum": momentum,
                                        "confidence": confidence,
                                        "pnl": result.get("pnl", 0),
                                        "pnl_pct": pnl_pct,
                                        "mode": trading_mode,
                                        "current_drawdown": current_drawdown,
                                        "circuit_breaker_state": {
                                            "quote": quote_breaker.get_state_info()["state"],
                                            "trade": trade_breaker.get_state_info()["state"]
                                        },
                                        "timestamp": dt.datetime.now(timezone.utc).isoformat()
                                    })
                                except Exception as trade_error:
                                    trade_breaker.record_failure()
                                    print(f"‚ùå Sell error: {trade_error}", flush=True)

                # TEST MODE: Sanity trade after 10 loops if no trades executed
                if trading_mode == "TEST_MODE" and loop_count >= 10 and state["trade_count"] == 0 and not state.get("test_trade_executed", False):
                    # Place a small test trade to validate order flow
                    test_symbol = crypto_symbols[0] if crypto_symbols else SYMBOLS[0]  # Use first crypto or first symbol

                    # --- World-Class Atomic Trade Execution ---
                    if quote_service:
                        try:
                            with atomic_trade_context(quote_service, test_symbol, max_age=10) as validated_quote:
                                # validated_quote.last_price is GUARANTEED to be a valid float
                                # CRITICAL: Convert to float explicitly (handles Decimal, string, etc.)
                                raw_price = validated_quote.last_price

                                # Convert to float safely (handles Decimal, string edge cases)
                                if isinstance(raw_price, (int, float)):
                                    test_price = float(raw_price)
                                else:
                                    # Handle Decimal or string edge cases
                                    test_price = safe_float_convert(raw_price, symbol=test_symbol, context="atomic quote last_price", state=state)
                                    if test_price is None:
                                        error_msg = f"Invalid price from atomic quote: {raw_price} ({type(raw_price)})"
                                        logger.error(f"‚ùå {error_msg}")
                                        raise ValueError(error_msg)

                                # CRITICAL: Verify price is actually a float before using
                                if not isinstance(test_price, (int, float)) or test_price <= 0:
                                    error_msg = f"Invalid price type after conversion: {test_price} ({type(test_price)})"
                                    logger.error(f"‚ùå {error_msg}")
                                    raise ValueError(error_msg)

                                logger.info(f"üß™ Using atomic quote: {test_symbol} @ ${test_price:,.2f} (seq={validated_quote.sequence_id}, type={type(test_price).__name__})")

                                # Small test trade: 0.001 BTC or equivalent
                                if test_symbol == "BTC-USD":
                                    test_qty = 0.001
                                elif test_symbol == "ETH-USD":
                                    test_qty = 0.01  # ETH equivalent
                                else:
                                    test_qty = max(0.001, 10.0 / test_price)  # $10 worth, minimum 0.001

                                # CRITICAL: Log exactly what we're passing to submit_order
                                logger.info(f"üîç About to call submit_order: symbol={test_symbol}, qty={test_qty} (type={type(test_qty).__name__}), price={test_price} (type={type(test_price).__name__})")

                                try:
                                    result = broker.submit_order(test_symbol, "buy", test_qty, test_price)
                                    trade_breaker.record_success()  # Successful trade
                                    state["last_trade"][test_symbol] = time.time()
                                    state["trade_count"] += 1
                                    state["test_trade_executed"] = True
                                    print(f"üß™ TEST TRADE: BUY {test_symbol}: {test_qty:.4f} @ ${test_price:.2f} | Fee: ${result.get('fee', 0):.2f}", flush=True)
                                    print(f"üí• Executed TEST BUY: {test_symbol} @ ${test_price:,.2f} | Size: {test_qty:.4f}", flush=True)
                                    send_telegram(
                                        f"üß™ TEST TRADE: BUY {test_symbol}\n"
                                        f"üìä Size: {test_qty:.4f} @ ${test_price:.2f}\n"
                                        f"üìà Quote seq: {validated_quote.sequence_id}",
                                        include_mode=True,
                                        state=state
                                    )

                                    # Send to Atlas Bridge
                                    send_to_atlas_bridge({
                                        "type": "test_trade",
                                        "symbol": test_symbol,
                                        "side": "buy",
                                        "qty": test_qty,
                                        "price": test_price,
                                        "quote_sequence": validated_quote.sequence_id,
                                        "mode": trading_mode,
                                        "timestamp": dt.datetime.now(timezone.utc).isoformat()
                                    })
                                except (ValueError, TypeError) as e:
                                    trade_breaker.record_failure()
                                    error_msg = f"Order validation error: {e}"
                                    logger.error(f"‚ùå Test trade validation error for {test_symbol}: {error_msg}")
                                    print(f"‚ùå Test trade error: {error_msg}", flush=True)
                                    send_telegram(
                                        f"‚ö†Ô∏è Test trade skipped: {test_symbol}\n"
                                        f"üìä Reason: {error_msg}",
                                        include_mode=True,
                                        state=state
                                    )
                                except Exception as e:
                                    trade_breaker.record_failure()
                                    logger.error(f"‚ùå Test trade execution error for {test_symbol}: {e}", exc_info=True)
                                    print(f"‚ùå Test trade error: {e}", flush=True)
                                    send_telegram(
                                        f"‚ö†Ô∏è Test trade execution error: {test_symbol}\n"
                                        f"üìä Error: {str(e)}",
                                        include_mode=True,
                                        state=state
                                    )
                        except ValueError as e:
                            logger.warning(f"‚ö†Ô∏è Test trade skipped: {test_symbol} - {e}")
                            send_telegram(
                                f"‚ö†Ô∏è Test trade skipped: {test_symbol}\n"
                                f"üìä Reason: {str(e)}",
                                include_mode=True,
                                state=state
                            )
                    else:
                        # Fallback to legacy quote fetching (if QuoteService unavailable)
                        quote = broker.fetch_quote(test_symbol)
                        if not quote:
                            logger.warning(f"‚ö†Ô∏è Could not fetch quote for test trade ({test_symbol}), skipping")
                            send_telegram(
                                f"‚ö†Ô∏è Test trade skipped: {test_symbol}\n"
                                f"üìä Reason: Could not fetch quote",
                                include_mode=True,
                                state=state
                            )
                        else:
                            # Use safe conversion function
                            test_price_candidate = quote.get("mid") or quote.get("last") or quote.get("regularMarketPrice") or quote.get("currentPrice")
                            safe_test_price = safe_float_convert(test_price_candidate, symbol=test_symbol, context="test trade price", state=state)
                            if safe_test_price is None:
                                logger.error(f"‚ùå Test trade validation error for {test_symbol}: Invalid or empty price in quote")
                                send_telegram(
                                    f"‚ö†Ô∏è Test trade skipped: {test_symbol}\n"
                                    f"üìä Reason: Invalid or empty price received from data source",
                                    include_mode=True,
                                    state=state
                                )
                                continue

                            test_price = safe_test_price

                            # Small test trade
                            if test_symbol == "BTC-USD":
                                test_qty = 0.001
                            elif test_symbol == "ETH-USD":
                                test_qty = 0.01
                            else:
                                test_qty = max(0.001, 10.0 / test_price)

                            try:
                                result = broker.submit_order(test_symbol, "buy", test_qty, test_price)
                                trade_breaker.record_success()
                                state["last_trade"][test_symbol] = time.time()
                                state["trade_count"] += 1
                                state["test_trade_executed"] = True
                                print(f"üß™ TEST TRADE: BUY {test_symbol}: {test_qty:.4f} @ ${test_price:.2f}", flush=True)
                                send_telegram(
                                    f"üß™ TEST TRADE: BUY {test_symbol}\n"
                                    f"üìä Size: {test_qty:.4f} @ ${test_price:.2f}",
                                    include_mode=True,
                                    state=state
                                )
                            except Exception as e:
                                trade_breaker.record_failure()
                                logger.error(f"‚ùå Test trade error for {test_symbol}: {e}")
                                send_telegram(
                                    f"‚ö†Ô∏è Test trade skipped: {test_symbol}\n"
                                    f"üìä Reason: {str(e)}",
                                    include_mode=True,
                                    state=state
                                )

                # Periodic state persistence (every 5 minutes)
                if loop_count % 60 == 0:  # Every 5 minutes (60 loops * 5 seconds)
                    try:
                        state_to_save = state.copy()
                        if "price_history" in state_to_save:
                            state_to_save["price_history"] = {
                                sym: list(prices) if isinstance(prices, deque) else prices
                                for sym, prices in state_to_save["price_history"].items()
                            }
                        state_file = ROOT / "state" / "trader_state.json"
                        with open(state_file, "w") as f:
                            json.dump(state_to_save, f, indent=4)
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Could not save state periodically: {e}")

                # PHASE 5400: Enhanced telemetry with Guardian + Circuit Breaker states
                if loop_count % 60 == 0:  # Every 5 minutes (60 loops * 5 seconds)
                    equity = broker.fetch_portfolio_value()
                    start_equity = state["daily"].get("start_equity", broker.equity)
                    daily_pnl_pct = (equity - start_equity) / max(1.0, start_equity) * 100
                    current_drawdown = -daily_pnl_pct if daily_pnl_pct < 0 else 0.0

                    # Get circuit breaker states
                    quote_state = quote_breaker.get_state_info()
                    trade_state = trade_breaker.get_state_info()

                    # Check for state changes and send Telegram alerts
                    if quote_state["state"] != last_circuit_states["quote"]:
                        if quote_state["state"] == "CLOSED":
                            send_telegram(
                                f"üü¢ Circuit breaker CLOSED\n"
                                f"üìä QuoteFetcher: Normal trading resumed",
                                include_mode=True,
                                state=state
                            )
                            print(f"üü¢ Circuit breaker CLOSED - QuoteFetcher: Normal trading resumed", flush=True)
                        elif quote_state["state"] == "OPEN":
                            send_telegram(
                                f"üî¥ Circuit breaker OPEN\n"
                                f"üìä QuoteFetcher: {quote_state['failure_count']} failures",
                                include_mode=True,
                                state=state
                            )
                        last_circuit_states["quote"] = quote_state["state"]

                    if trade_state["state"] != last_circuit_states["trade"]:
                        if trade_state["state"] == "CLOSED":
                            send_telegram(
                                f"üü¢ Circuit breaker CLOSED\n"
                                f"üìä TradeExecution: Normal trading resumed",
                                include_mode=True,
                                state=state
                            )
                            print(f"üü¢ Circuit breaker CLOSED - TradeExecution: Normal trading resumed", flush=True)
                        elif trade_state["state"] == "OPEN":
                            send_telegram(
                                f"üî¥ Circuit breaker OPEN\n"
                                f"üìä TradeExecution: {trade_state['failure_count']} failures",
                                include_mode=True,
                                state=state
                            )
                        last_circuit_states["trade"] = trade_state["state"]

                    # Enhanced telemetry payload
                    telemetry_data = {
                        "type": "telemetry",
                        "equity": equity,
                        "cash": broker.cash,
                        "daily_pnl_pct": daily_pnl_pct,
                        "current_drawdown": current_drawdown,
                        "mode": trading_mode,
                        "trade_count": state["trade_count"],
                        "test_sells": state.get("test_sells", 0),
                        "loop_count": loop_count,
                        "guardian": {
                            "is_paused": is_paused,
                            "current_drawdown": current_drawdown,
                            "pause_reason": pause_reason if is_paused else "Normal operation"
                        },
                        "circuit_breakers": {
                            "quote_fetcher": quote_state,
                            "trade_execution": trade_state
                        },
                        "timestamp": dt.datetime.now(timezone.utc).isoformat()
                    }

                    send_to_atlas_bridge(telemetry_data)

                    # PHASE 5600: Push to meta-metrics endpoint as well
                    try:
                        import sys
                        sys.path.insert(0, str(ROOT))
                        from agents.phase_5600_hive_telemetry import build_meta_metrics, push_to_meta_metrics
                        # Update mode in metrics
                        meta_metrics = build_meta_metrics()
                        meta_metrics["mode"] = trading_mode
                        meta_metrics["guardian"]["drawdown"] = current_drawdown
                        meta_metrics["guardian"]["is_paused"] = is_paused
                        meta_metrics["breakers"]["quote_state"] = quote_state["state"]
                        meta_metrics["breakers"]["trade_state"] = trade_state["state"]
                        push_to_meta_metrics(meta_metrics)
                    except Exception as e:
                        pass  # Silent fail if Phase 5600 not available

                    # Log state summary every 5 minutes
                    print(f"üìä Phase 5400 Telemetry: Drawdown={current_drawdown:.2f}% | Quote={quote_state['state']} | Trade={trade_state['state']} | Mode={trading_mode}", flush=True)

                # Hourly status update
                if loop_count % 3600 == 0:  # Every hour (assuming 1s sleep)
                    equity = broker.fetch_portfolio_value()
                    start_equity = state["daily"].get("start_equity", broker.equity)
                    daily_pnl_pct = (equity - start_equity) / max(1.0, start_equity) * 100
                    print(f"‚è∞ Hourly Status | Equity: ${equity:,.2f} | Daily P&L: {daily_pnl_pct:.2f}% | Trades: {state['trade_count']}", flush=True)
                    send_telegram(
                        f"‚è∞ Hourly Status\n"
                        f"üí∞ Equity: ${equity:,.2f}\n"
                        f"üìä Daily P&L: {daily_pnl_pct:.2f}%\n"
                        f"üìà Trades: {state['trade_count']}",
                        include_mode=True,
                        state=state
                    )

                time.sleep(5)  # Check every 5 seconds

            except KeyboardInterrupt:
                stop_flag["stop"] = True
                break
            except Exception as e:
                consecutive_errors += 1
                print(f"üí• Loop error ({consecutive_errors}/{MAX_CONSECUTIVE_ERRORS}): {e}", flush=True)
                if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                    print("‚ùå Too many consecutive errors - exiting for Guardian to restart", flush=True)
                    send_telegram(
                        f"‚ùå SmartTrader exiting after {consecutive_errors} errors\n"
                        f"üîÑ Guardian will restart automatically",
                        include_mode=True,
                        state=state
                    )
                    break
                traceback.print_exc()
                time.sleep(10)

    except KeyboardInterrupt:
        logger.warning("üõë SmartTrader manually stopped (KeyboardInterrupt)")
        print("üõë SmartTrader manually stopped.", flush=True)
    except Exception as e:
        logger.exception(f"üí• Unhandled exception in SmartTrader: {e}")
        print(f"üí• Unhandled exception: {e}", flush=True)
        send_telegram(
            f"‚ùå SmartTrader crashed: {str(e)}\n"
            f"üîÑ Guardian will restart automatically",
            include_mode=True,
            state=state
        )
    finally:
        # --- Final state persistence on exit ---
        try:
            # Ensure state directory exists
            (ROOT / "state").mkdir(parents=True, exist_ok=True)

            # Convert deque to list for JSON serialization
            state_to_save = state.copy()
            if "price_history" in state_to_save:
                state_to_save["price_history"] = {
                    sym: list(prices) if isinstance(prices, deque) else prices
                    for sym, prices in state_to_save["price_history"].items()
                }

            # Save state
            with open(state_file, "w") as f:
                json.dump(state_to_save, f, indent=4)
            logger.info("‚úÖ State saved successfully on exit")
        except Exception as e:
            logger.error(f"‚ùå Failed to save state on exit: {e}")

    # Final summary
    try:
        final_equity = broker.fetch_portfolio_value()
        total_return = (final_equity - 100000.0) / 100000.0 * 100
        print(f"\nüëã Final Summary:")
        print(f"   Starting Equity: $100,000.00")
        print(f"   Final Equity: ${final_equity:,.2f}")
        print(f"   Total Return: {total_return:.2f}%")
        print(f"   Total Trades: {state.get('trade_count', 0)}", flush=True)
        send_telegram(
            f"üëã SmartTrader stopped\n"
            f"üí∞ Final Equity: ${final_equity:,.2f}\n"
            f"üìä Total Return: {total_return:.2f}%",
            include_mode=True,
            state=state
        )
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Could not generate final summary: {e}")

    print("üëã Exiting cleanly.", flush=True)

if __name__ == "__main__":
    main()
